// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: airmobisim.proto

#include "airmobisim.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace airmobisim {
PROTOBUF_CONSTEXPR WaypointList::WaypointList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.waypoint_)*/{}
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WaypointListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WaypointListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WaypointListDefaultTypeInternal() {}
  union {
    WaypointList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WaypointListDefaultTypeInternal _WaypointList_default_instance_;
PROTOBUF_CONSTEXPR Waypoint::Waypoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.uid_)*/0
  , /*decltype(_impl_.index_)*/0
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WaypointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WaypointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WaypointDefaultTypeInternal() {}
  union {
    Waypoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WaypointDefaultTypeInternal _Waypoint_default_instance_;
PROTOBUF_CONSTEXPR UavList::UavList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.uavs_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UavListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UavListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UavListDefaultTypeInternal() {}
  union {
    UavList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UavListDefaultTypeInternal _UavList_default_instance_;
PROTOBUF_CONSTEXPR Uav::Uav(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.speed_)*/0
  , /*decltype(_impl_.angle_)*/0
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UavDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UavDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UavDefaultTypeInternal() {}
  union {
    Uav _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UavDefaultTypeInternal _Uav_default_instance_;
PROTOBUF_CONSTEXPR Response::Response(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.speed_)*/0
  , /*decltype(_impl_.angle_)*/0
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseDefaultTypeInternal() {}
  union {
    Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseDefaultTypeInternal _Response_default_instance_;
PROTOBUF_CONSTEXPR ResponseQuery::ResponseQuery(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.responses_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ResponseQueryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseQueryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseQueryDefaultTypeInternal() {}
  union {
    ResponseQuery _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseQueryDefaultTypeInternal _ResponseQuery_default_instance_;
PROTOBUF_CONSTEXPR StartUav::StartUav(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.coordinates_)*/{}
  , /*decltype(_impl_.speed_)*/0
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.mobilitymodel_)*/0
  , /*decltype(_impl_.angle_)*/0
  , /*decltype(_impl_.removenode_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StartUavDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StartUavDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StartUavDefaultTypeInternal() {}
  union {
    StartUav _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StartUavDefaultTypeInternal _StartUav_default_instance_;
PROTOBUF_CONSTEXPR Coordinates::Coordinates(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CoordinatesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CoordinatesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CoordinatesDefaultTypeInternal() {}
  union {
    Coordinates _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CoordinatesDefaultTypeInternal _Coordinates_default_instance_;
PROTOBUF_CONSTEXPR Number::Number(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.num_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NumberDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NumberDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NumberDefaultTypeInternal() {}
  union {
    Number _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NumberDefaultTypeInternal _Number_default_instance_;
PROTOBUF_CONSTEXPR DoubleNumber::DoubleNumber(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.num_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DoubleNumberDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoubleNumberDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoubleNumberDefaultTypeInternal() {}
  union {
    DoubleNumber _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoubleNumberDefaultTypeInternal _DoubleNumber_default_instance_;
PROTOBUF_CONSTEXPR UavSetSpeed::UavSetSpeed(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.speed_)*/0
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UavSetSpeedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UavSetSpeedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UavSetSpeedDefaultTypeInternal() {}
  union {
    UavSetSpeed _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UavSetSpeedDefaultTypeInternal _UavSetSpeed_default_instance_;
}  // namespace airmobisim
static ::_pb::Metadata file_level_metadata_airmobisim_2eproto[11];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_airmobisim_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_airmobisim_2eproto = nullptr;

const uint32_t TableStruct_airmobisim_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::airmobisim::WaypointList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::airmobisim::WaypointList, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::WaypointList, _impl_.waypoint_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::airmobisim::Waypoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::airmobisim::Waypoint, _impl_.uid_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::Waypoint, _impl_.index_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::Waypoint, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::Waypoint, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::Waypoint, _impl_.z_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::airmobisim::UavList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::airmobisim::UavList, _impl_.uavs_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::airmobisim::Uav, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::airmobisim::Uav, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::Uav, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::Uav, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::Uav, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::Uav, _impl_.speed_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::Uav, _impl_.angle_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::airmobisim::Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::airmobisim::Response, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::Response, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::Response, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::Response, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::Response, _impl_.speed_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::Response, _impl_.angle_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::airmobisim::ResponseQuery, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::airmobisim::ResponseQuery, _impl_.responses_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::airmobisim::StartUav, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::airmobisim::StartUav, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::StartUav, _impl_.coordinates_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::StartUav, _impl_.speed_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::StartUav, _impl_.angle_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::StartUav, _impl_.mobilitymodel_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::StartUav, _impl_.removenode_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::airmobisim::Coordinates, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::airmobisim::Coordinates, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::Coordinates, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::Coordinates, _impl_.z_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::airmobisim::Number, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::airmobisim::Number, _impl_.num_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::airmobisim::DoubleNumber, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::airmobisim::DoubleNumber, _impl_.num_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::airmobisim::UavSetSpeed, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::airmobisim::UavSetSpeed, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::airmobisim::UavSetSpeed, _impl_.speed_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::airmobisim::WaypointList)},
  { 8, -1, -1, sizeof(::airmobisim::Waypoint)},
  { 19, -1, -1, sizeof(::airmobisim::UavList)},
  { 26, -1, -1, sizeof(::airmobisim::Uav)},
  { 38, -1, -1, sizeof(::airmobisim::Response)},
  { 50, -1, -1, sizeof(::airmobisim::ResponseQuery)},
  { 57, -1, -1, sizeof(::airmobisim::StartUav)},
  { 69, -1, -1, sizeof(::airmobisim::Coordinates)},
  { 78, -1, -1, sizeof(::airmobisim::Number)},
  { 85, -1, -1, sizeof(::airmobisim::DoubleNumber)},
  { 92, -1, -1, sizeof(::airmobisim::UavSetSpeed)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::airmobisim::_WaypointList_default_instance_._instance,
  &::airmobisim::_Waypoint_default_instance_._instance,
  &::airmobisim::_UavList_default_instance_._instance,
  &::airmobisim::_Uav_default_instance_._instance,
  &::airmobisim::_Response_default_instance_._instance,
  &::airmobisim::_ResponseQuery_default_instance_._instance,
  &::airmobisim::_StartUav_default_instance_._instance,
  &::airmobisim::_Coordinates_default_instance_._instance,
  &::airmobisim::_Number_default_instance_._instance,
  &::airmobisim::_DoubleNumber_default_instance_._instance,
  &::airmobisim::_UavSetSpeed_default_instance_._instance,
};

const char descriptor_table_protodef_airmobisim_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\020airmobisim.proto\022\nairmobisim\032\033google/p"
  "rotobuf/empty.proto\"B\n\014WaypointList\022\n\n\002i"
  "d\030\001 \001(\005\022&\n\010waypoint\030\002 \003(\0132\024.airmobisim.W"
  "aypoint\"G\n\010Waypoint\022\013\n\003uid\030\001 \001(\021\022\r\n\005inde"
  "x\030\002 \001(\005\022\t\n\001x\030\003 \001(\001\022\t\n\001y\030\004 \001(\001\022\t\n\001z\030\005 \001(\001"
  "\"(\n\007UavList\022\035\n\004uavs\030\001 \003(\0132\017.airmobisim.U"
  "av\"P\n\003Uav\022\n\n\002id\030\001 \001(\005\022\t\n\001x\030\002 \001(\001\022\t\n\001y\030\003 "
  "\001(\001\022\t\n\001z\030\004 \001(\001\022\r\n\005speed\030\005 \001(\001\022\r\n\005angle\030\006"
  " \001(\001\"U\n\010Response\022\n\n\002id\030\001 \001(\005\022\t\n\001x\030\002 \001(\001\022"
  "\t\n\001y\030\003 \001(\001\022\t\n\001z\030\004 \001(\001\022\r\n\005speed\030\005 \001(\001\022\r\n\005"
  "angle\030\006 \001(\001\"8\n\rResponseQuery\022\'\n\tresponse"
  "s\030\001 \003(\0132\024.airmobisim.Response\"\215\001\n\010StartU"
  "av\022\n\n\002id\030\001 \001(\005\022,\n\013coordinates\030\002 \003(\0132\027.ai"
  "rmobisim.Coordinates\022\r\n\005speed\030\003 \001(\001\022\r\n\005a"
  "ngle\030\004 \001(\001\022\025\n\rmobilityModel\030\005 \001(\005\022\022\n\nrem"
  "oveNode\030\006 \001(\010\".\n\013Coordinates\022\t\n\001x\030\001 \001(\001\022"
  "\t\n\001y\030\002 \001(\001\022\t\n\001z\030\003 \001(\001\"\025\n\006Number\022\013\n\003num\030\001"
  " \001(\005\"\033\n\014DoubleNumber\022\013\n\003num\030\001 \001(\001\"(\n\013Uav"
  "SetSpeed\022\n\n\002id\030\001 \001(\005\022\r\n\005speed\030\002 \001(\0012\333\007\n\n"
  "AirMobiSim\0227\n\005Start\022\026.google.protobuf.Em"
  "pty\032\026.google.protobuf.Empty\022G\n\022ExecuteOn"
  "eTimeStep\022\026.google.protobuf.Empty\032\031.airm"
  "obisim.ResponseQuery\0228\n\006Finish\022\026.google."
  "protobuf.Empty\032\026.google.protobuf.Empty\022>"
  "\n\017GetManagedHosts\022\026.google.protobuf.Empt"
  "y\032\023.airmobisim.UavList\022C\n\017InsertWaypoint"
  "s\022\030.airmobisim.WaypointList\032\026.google.pro"
  "tobuf.Empty\022>\n\016InsertWaypoint\022\024.airmobis"
  "im.Waypoint\032\026.google.protobuf.Empty\0229\n\tI"
  "nsertUAV\022\024.airmobisim.StartUav\032\026.google."
  "protobuf.Empty\0229\n\013getMaxUavId\022\026.google.p"
  "rotobuf.Empty\032\022.airmobisim.Number\0227\n\tDel"
  "eteUAV\022\022.airmobisim.Number\032\026.google.prot"
  "obuf.Empty\022A\n\023getNumberCurrentUAV\022\026.goog"
  "le.protobuf.Empty\032\022.airmobisim.Number\022B\n"
  "\017SetDesiredSpeed\022\027.airmobisim.UavSetSpee"
  "d\032\026.google.protobuf.Empty\022C\n\017UpdateWaypo"
  "ints\022\030.airmobisim.WaypointList\032\026.google."
  "protobuf.Empty\022B\n\016DeleteWaypoint\022\030.airmo"
  "bisim.WaypointList\032\026.google.protobuf.Emp"
  "ty\022B\n\024GetMaxSimulationTime\022\026.google.prot"
  "obuf.Empty\032\022.airmobisim.Number\022I\n\025getMax"
  "SimulationSteps\022\026.google.protobuf.Empty\032"
  "\030.airmobisim.DoubleNumberb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_airmobisim_2eproto_deps[1] = {
  &::descriptor_table_google_2fprotobuf_2fempty_2eproto,
};
static ::_pbi::once_flag descriptor_table_airmobisim_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_airmobisim_2eproto = {
    false, false, 1753, descriptor_table_protodef_airmobisim_2eproto,
    "airmobisim.proto",
    &descriptor_table_airmobisim_2eproto_once, descriptor_table_airmobisim_2eproto_deps, 1, 11,
    schemas, file_default_instances, TableStruct_airmobisim_2eproto::offsets,
    file_level_metadata_airmobisim_2eproto, file_level_enum_descriptors_airmobisim_2eproto,
    file_level_service_descriptors_airmobisim_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_airmobisim_2eproto_getter() {
  return &descriptor_table_airmobisim_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_airmobisim_2eproto(&descriptor_table_airmobisim_2eproto);
namespace airmobisim {

// ===================================================================

class WaypointList::_Internal {
 public:
};

WaypointList::WaypointList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:airmobisim.WaypointList)
}
WaypointList::WaypointList(const WaypointList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WaypointList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.waypoint_){from._impl_.waypoint_}
    , decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:airmobisim.WaypointList)
}

inline void WaypointList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.waypoint_){arena}
    , decltype(_impl_.id_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

WaypointList::~WaypointList() {
  // @@protoc_insertion_point(destructor:airmobisim.WaypointList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WaypointList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.waypoint_.~RepeatedPtrField();
}

void WaypointList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WaypointList::Clear() {
// @@protoc_insertion_point(message_clear_start:airmobisim.WaypointList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.waypoint_.Clear();
  _impl_.id_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WaypointList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .airmobisim.Waypoint waypoint = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_waypoint(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WaypointList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:airmobisim.WaypointList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // repeated .airmobisim.Waypoint waypoint = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_waypoint_size()); i < n; i++) {
    const auto& repfield = this->_internal_waypoint(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:airmobisim.WaypointList)
  return target;
}

size_t WaypointList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:airmobisim.WaypointList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .airmobisim.Waypoint waypoint = 2;
  total_size += 1UL * this->_internal_waypoint_size();
  for (const auto& msg : this->_impl_.waypoint_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WaypointList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WaypointList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WaypointList::GetClassData() const { return &_class_data_; }


void WaypointList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WaypointList*>(&to_msg);
  auto& from = static_cast<const WaypointList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:airmobisim.WaypointList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.waypoint_.MergeFrom(from._impl_.waypoint_);
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WaypointList::CopyFrom(const WaypointList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:airmobisim.WaypointList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WaypointList::IsInitialized() const {
  return true;
}

void WaypointList::InternalSwap(WaypointList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.waypoint_.InternalSwap(&other->_impl_.waypoint_);
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata WaypointList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_airmobisim_2eproto_getter, &descriptor_table_airmobisim_2eproto_once,
      file_level_metadata_airmobisim_2eproto[0]);
}

// ===================================================================

class Waypoint::_Internal {
 public:
};

Waypoint::Waypoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:airmobisim.Waypoint)
}
Waypoint::Waypoint(const Waypoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Waypoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.uid_){}
    , decltype(_impl_.index_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.uid_, &from._impl_.uid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.uid_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:airmobisim.Waypoint)
}

inline void Waypoint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.uid_){0}
    , decltype(_impl_.index_){0}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Waypoint::~Waypoint() {
  // @@protoc_insertion_point(destructor:airmobisim.Waypoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Waypoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Waypoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Waypoint::Clear() {
// @@protoc_insertion_point(message_clear_start:airmobisim.Waypoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.uid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.uid_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Waypoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // sint32 uid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double x = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double y = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double z = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Waypoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:airmobisim.Waypoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // sint32 uid = 1;
  if (this->_internal_uid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(1, this->_internal_uid(), target);
  }

  // int32 index = 2;
  if (this->_internal_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_index(), target);
  }

  // double x = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_x(), target);
  }

  // double y = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_y(), target);
  }

  // double z = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:airmobisim.Waypoint)
  return target;
}

size_t Waypoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:airmobisim.Waypoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // sint32 uid = 1;
  if (this->_internal_uid() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_uid());
  }

  // int32 index = 2;
  if (this->_internal_index() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_index());
  }

  // double x = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 8;
  }

  // double y = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 8;
  }

  // double z = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Waypoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Waypoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Waypoint::GetClassData() const { return &_class_data_; }


void Waypoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Waypoint*>(&to_msg);
  auto& from = static_cast<const Waypoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:airmobisim.Waypoint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_uid() != 0) {
    _this->_internal_set_uid(from._internal_uid());
  }
  if (from._internal_index() != 0) {
    _this->_internal_set_index(from._internal_index());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Waypoint::CopyFrom(const Waypoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:airmobisim.Waypoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Waypoint::IsInitialized() const {
  return true;
}

void Waypoint::InternalSwap(Waypoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.z_)
      + sizeof(Waypoint::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.uid_)>(
          reinterpret_cast<char*>(&_impl_.uid_),
          reinterpret_cast<char*>(&other->_impl_.uid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Waypoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_airmobisim_2eproto_getter, &descriptor_table_airmobisim_2eproto_once,
      file_level_metadata_airmobisim_2eproto[1]);
}

// ===================================================================

class UavList::_Internal {
 public:
};

UavList::UavList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:airmobisim.UavList)
}
UavList::UavList(const UavList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UavList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.uavs_){from._impl_.uavs_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:airmobisim.UavList)
}

inline void UavList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.uavs_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UavList::~UavList() {
  // @@protoc_insertion_point(destructor:airmobisim.UavList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UavList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.uavs_.~RepeatedPtrField();
}

void UavList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UavList::Clear() {
// @@protoc_insertion_point(message_clear_start:airmobisim.UavList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.uavs_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UavList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .airmobisim.Uav uavs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_uavs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UavList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:airmobisim.UavList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .airmobisim.Uav uavs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_uavs_size()); i < n; i++) {
    const auto& repfield = this->_internal_uavs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:airmobisim.UavList)
  return target;
}

size_t UavList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:airmobisim.UavList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .airmobisim.Uav uavs = 1;
  total_size += 1UL * this->_internal_uavs_size();
  for (const auto& msg : this->_impl_.uavs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UavList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UavList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UavList::GetClassData() const { return &_class_data_; }


void UavList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UavList*>(&to_msg);
  auto& from = static_cast<const UavList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:airmobisim.UavList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.uavs_.MergeFrom(from._impl_.uavs_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UavList::CopyFrom(const UavList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:airmobisim.UavList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UavList::IsInitialized() const {
  return true;
}

void UavList::InternalSwap(UavList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.uavs_.InternalSwap(&other->_impl_.uavs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UavList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_airmobisim_2eproto_getter, &descriptor_table_airmobisim_2eproto_once,
      file_level_metadata_airmobisim_2eproto[2]);
}

// ===================================================================

class Uav::_Internal {
 public:
};

Uav::Uav(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:airmobisim.Uav)
}
Uav::Uav(const Uav& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Uav* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.speed_){}
    , decltype(_impl_.angle_){}
    , decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.id_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.id_));
  // @@protoc_insertion_point(copy_constructor:airmobisim.Uav)
}

inline void Uav::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.speed_){0}
    , decltype(_impl_.angle_){0}
    , decltype(_impl_.id_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Uav::~Uav() {
  // @@protoc_insertion_point(destructor:airmobisim.Uav)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Uav::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Uav::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Uav::Clear() {
// @@protoc_insertion_point(message_clear_start:airmobisim.Uav)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.id_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Uav::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double x = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double z = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double speed = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double angle = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _impl_.angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Uav::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:airmobisim.Uav)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // double x = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_x(), target);
  }

  // double y = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_y(), target);
  }

  // double z = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_z(), target);
  }

  // double speed = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = this->_internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_speed(), target);
  }

  // double angle = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_angle = this->_internal_angle();
  uint64_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_angle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:airmobisim.Uav)
  return target;
}

size_t Uav::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:airmobisim.Uav)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 8;
  }

  // double y = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 8;
  }

  // double z = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 8;
  }

  // double speed = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = this->_internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    total_size += 1 + 8;
  }

  // double angle = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_angle = this->_internal_angle();
  uint64_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    total_size += 1 + 8;
  }

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Uav::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Uav::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Uav::GetClassData() const { return &_class_data_; }


void Uav::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Uav*>(&to_msg);
  auto& from = static_cast<const Uav&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:airmobisim.Uav)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = from._internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    _this->_internal_set_speed(from._internal_speed());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_angle = from._internal_angle();
  uint64_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    _this->_internal_set_angle(from._internal_angle());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Uav::CopyFrom(const Uav& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:airmobisim.Uav)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Uav::IsInitialized() const {
  return true;
}

void Uav::InternalSwap(Uav* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Uav, _impl_.id_)
      + sizeof(Uav::_impl_.id_)
      - PROTOBUF_FIELD_OFFSET(Uav, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Uav::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_airmobisim_2eproto_getter, &descriptor_table_airmobisim_2eproto_once,
      file_level_metadata_airmobisim_2eproto[3]);
}

// ===================================================================

class Response::_Internal {
 public:
};

Response::Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:airmobisim.Response)
}
Response::Response(const Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Response* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.speed_){}
    , decltype(_impl_.angle_){}
    , decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.id_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.id_));
  // @@protoc_insertion_point(copy_constructor:airmobisim.Response)
}

inline void Response::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.speed_){0}
    , decltype(_impl_.angle_){0}
    , decltype(_impl_.id_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Response::~Response() {
  // @@protoc_insertion_point(destructor:airmobisim.Response)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Response::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Response::Clear() {
// @@protoc_insertion_point(message_clear_start:airmobisim.Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.id_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Response::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double x = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double z = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double speed = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double angle = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _impl_.angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:airmobisim.Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // double x = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_x(), target);
  }

  // double y = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_y(), target);
  }

  // double z = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_z(), target);
  }

  // double speed = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = this->_internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_speed(), target);
  }

  // double angle = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_angle = this->_internal_angle();
  uint64_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_angle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:airmobisim.Response)
  return target;
}

size_t Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:airmobisim.Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 8;
  }

  // double y = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 8;
  }

  // double z = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 8;
  }

  // double speed = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = this->_internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    total_size += 1 + 8;
  }

  // double angle = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_angle = this->_internal_angle();
  uint64_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    total_size += 1 + 8;
  }

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Response::GetClassData() const { return &_class_data_; }


void Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Response*>(&to_msg);
  auto& from = static_cast<const Response&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:airmobisim.Response)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = from._internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    _this->_internal_set_speed(from._internal_speed());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_angle = from._internal_angle();
  uint64_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    _this->_internal_set_angle(from._internal_angle());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Response::CopyFrom(const Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:airmobisim.Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Response::IsInitialized() const {
  return true;
}

void Response::InternalSwap(Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Response, _impl_.id_)
      + sizeof(Response::_impl_.id_)
      - PROTOBUF_FIELD_OFFSET(Response, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Response::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_airmobisim_2eproto_getter, &descriptor_table_airmobisim_2eproto_once,
      file_level_metadata_airmobisim_2eproto[4]);
}

// ===================================================================

class ResponseQuery::_Internal {
 public:
};

ResponseQuery::ResponseQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:airmobisim.ResponseQuery)
}
ResponseQuery::ResponseQuery(const ResponseQuery& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseQuery* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.responses_){from._impl_.responses_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:airmobisim.ResponseQuery)
}

inline void ResponseQuery::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.responses_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ResponseQuery::~ResponseQuery() {
  // @@protoc_insertion_point(destructor:airmobisim.ResponseQuery)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseQuery::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.responses_.~RepeatedPtrField();
}

void ResponseQuery::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseQuery::Clear() {
// @@protoc_insertion_point(message_clear_start:airmobisim.ResponseQuery)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.responses_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseQuery::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .airmobisim.Response responses = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_responses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseQuery::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:airmobisim.ResponseQuery)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .airmobisim.Response responses = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_responses_size()); i < n; i++) {
    const auto& repfield = this->_internal_responses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:airmobisim.ResponseQuery)
  return target;
}

size_t ResponseQuery::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:airmobisim.ResponseQuery)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .airmobisim.Response responses = 1;
  total_size += 1UL * this->_internal_responses_size();
  for (const auto& msg : this->_impl_.responses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseQuery::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseQuery::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseQuery::GetClassData() const { return &_class_data_; }


void ResponseQuery::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseQuery*>(&to_msg);
  auto& from = static_cast<const ResponseQuery&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:airmobisim.ResponseQuery)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.responses_.MergeFrom(from._impl_.responses_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseQuery::CopyFrom(const ResponseQuery& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:airmobisim.ResponseQuery)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseQuery::IsInitialized() const {
  return true;
}

void ResponseQuery::InternalSwap(ResponseQuery* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.responses_.InternalSwap(&other->_impl_.responses_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseQuery::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_airmobisim_2eproto_getter, &descriptor_table_airmobisim_2eproto_once,
      file_level_metadata_airmobisim_2eproto[5]);
}

// ===================================================================

class StartUav::_Internal {
 public:
};

StartUav::StartUav(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:airmobisim.StartUav)
}
StartUav::StartUav(const StartUav& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StartUav* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.coordinates_){from._impl_.coordinates_}
    , decltype(_impl_.speed_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.mobilitymodel_){}
    , decltype(_impl_.angle_){}
    , decltype(_impl_.removenode_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.speed_, &from._impl_.speed_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.removenode_) -
    reinterpret_cast<char*>(&_impl_.speed_)) + sizeof(_impl_.removenode_));
  // @@protoc_insertion_point(copy_constructor:airmobisim.StartUav)
}

inline void StartUav::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.coordinates_){arena}
    , decltype(_impl_.speed_){0}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.mobilitymodel_){0}
    , decltype(_impl_.angle_){0}
    , decltype(_impl_.removenode_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StartUav::~StartUav() {
  // @@protoc_insertion_point(destructor:airmobisim.StartUav)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StartUav::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.coordinates_.~RepeatedPtrField();
}

void StartUav::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StartUav::Clear() {
// @@protoc_insertion_point(message_clear_start:airmobisim.StartUav)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.coordinates_.Clear();
  ::memset(&_impl_.speed_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.removenode_) -
      reinterpret_cast<char*>(&_impl_.speed_)) + sizeof(_impl_.removenode_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StartUav::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .airmobisim.Coordinates coordinates = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_coordinates(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // double speed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double angle = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 mobilityModel = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.mobilitymodel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool removeNode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.removenode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StartUav::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:airmobisim.StartUav)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // repeated .airmobisim.Coordinates coordinates = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_coordinates_size()); i < n; i++) {
    const auto& repfield = this->_internal_coordinates(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // double speed = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = this->_internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_speed(), target);
  }

  // double angle = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_angle = this->_internal_angle();
  uint64_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_angle(), target);
  }

  // int32 mobilityModel = 5;
  if (this->_internal_mobilitymodel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_mobilitymodel(), target);
  }

  // bool removeNode = 6;
  if (this->_internal_removenode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_removenode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:airmobisim.StartUav)
  return target;
}

size_t StartUav::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:airmobisim.StartUav)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .airmobisim.Coordinates coordinates = 2;
  total_size += 1UL * this->_internal_coordinates_size();
  for (const auto& msg : this->_impl_.coordinates_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // double speed = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = this->_internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    total_size += 1 + 8;
  }

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  // int32 mobilityModel = 5;
  if (this->_internal_mobilitymodel() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mobilitymodel());
  }

  // double angle = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_angle = this->_internal_angle();
  uint64_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    total_size += 1 + 8;
  }

  // bool removeNode = 6;
  if (this->_internal_removenode() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StartUav::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StartUav::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StartUav::GetClassData() const { return &_class_data_; }


void StartUav::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StartUav*>(&to_msg);
  auto& from = static_cast<const StartUav&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:airmobisim.StartUav)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.coordinates_.MergeFrom(from._impl_.coordinates_);
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = from._internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    _this->_internal_set_speed(from._internal_speed());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_mobilitymodel() != 0) {
    _this->_internal_set_mobilitymodel(from._internal_mobilitymodel());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_angle = from._internal_angle();
  uint64_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    _this->_internal_set_angle(from._internal_angle());
  }
  if (from._internal_removenode() != 0) {
    _this->_internal_set_removenode(from._internal_removenode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StartUav::CopyFrom(const StartUav& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:airmobisim.StartUav)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartUav::IsInitialized() const {
  return true;
}

void StartUav::InternalSwap(StartUav* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.coordinates_.InternalSwap(&other->_impl_.coordinates_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StartUav, _impl_.removenode_)
      + sizeof(StartUav::_impl_.removenode_)
      - PROTOBUF_FIELD_OFFSET(StartUav, _impl_.speed_)>(
          reinterpret_cast<char*>(&_impl_.speed_),
          reinterpret_cast<char*>(&other->_impl_.speed_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StartUav::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_airmobisim_2eproto_getter, &descriptor_table_airmobisim_2eproto_once,
      file_level_metadata_airmobisim_2eproto[6]);
}

// ===================================================================

class Coordinates::_Internal {
 public:
};

Coordinates::Coordinates(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:airmobisim.Coordinates)
}
Coordinates::Coordinates(const Coordinates& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Coordinates* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:airmobisim.Coordinates)
}

inline void Coordinates::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Coordinates::~Coordinates() {
  // @@protoc_insertion_point(destructor:airmobisim.Coordinates)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Coordinates::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Coordinates::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Coordinates::Clear() {
// @@protoc_insertion_point(message_clear_start:airmobisim.Coordinates)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Coordinates::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Coordinates::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:airmobisim.Coordinates)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:airmobisim.Coordinates)
  return target;
}

size_t Coordinates::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:airmobisim.Coordinates)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 8;
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 8;
  }

  // double z = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Coordinates::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Coordinates::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Coordinates::GetClassData() const { return &_class_data_; }


void Coordinates::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Coordinates*>(&to_msg);
  auto& from = static_cast<const Coordinates&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:airmobisim.Coordinates)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Coordinates::CopyFrom(const Coordinates& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:airmobisim.Coordinates)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Coordinates::IsInitialized() const {
  return true;
}

void Coordinates::InternalSwap(Coordinates* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Coordinates, _impl_.z_)
      + sizeof(Coordinates::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(Coordinates, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Coordinates::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_airmobisim_2eproto_getter, &descriptor_table_airmobisim_2eproto_once,
      file_level_metadata_airmobisim_2eproto[7]);
}

// ===================================================================

class Number::_Internal {
 public:
};

Number::Number(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:airmobisim.Number)
}
Number::Number(const Number& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Number* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.num_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.num_ = from._impl_.num_;
  // @@protoc_insertion_point(copy_constructor:airmobisim.Number)
}

inline void Number::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.num_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Number::~Number() {
  // @@protoc_insertion_point(destructor:airmobisim.Number)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Number::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Number::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Number::Clear() {
// @@protoc_insertion_point(message_clear_start:airmobisim.Number)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.num_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Number::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Number::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:airmobisim.Number)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 num = 1;
  if (this->_internal_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_num(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:airmobisim.Number)
  return target;
}

size_t Number::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:airmobisim.Number)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 num = 1;
  if (this->_internal_num() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Number::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Number::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Number::GetClassData() const { return &_class_data_; }


void Number::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Number*>(&to_msg);
  auto& from = static_cast<const Number&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:airmobisim.Number)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_num() != 0) {
    _this->_internal_set_num(from._internal_num());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Number::CopyFrom(const Number& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:airmobisim.Number)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Number::IsInitialized() const {
  return true;
}

void Number::InternalSwap(Number* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.num_, other->_impl_.num_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Number::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_airmobisim_2eproto_getter, &descriptor_table_airmobisim_2eproto_once,
      file_level_metadata_airmobisim_2eproto[8]);
}

// ===================================================================

class DoubleNumber::_Internal {
 public:
};

DoubleNumber::DoubleNumber(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:airmobisim.DoubleNumber)
}
DoubleNumber::DoubleNumber(const DoubleNumber& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DoubleNumber* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.num_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.num_ = from._impl_.num_;
  // @@protoc_insertion_point(copy_constructor:airmobisim.DoubleNumber)
}

inline void DoubleNumber::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.num_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DoubleNumber::~DoubleNumber() {
  // @@protoc_insertion_point(destructor:airmobisim.DoubleNumber)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DoubleNumber::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DoubleNumber::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DoubleNumber::Clear() {
// @@protoc_insertion_point(message_clear_start:airmobisim.DoubleNumber)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.num_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DoubleNumber::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.num_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DoubleNumber::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:airmobisim.DoubleNumber)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double num = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_num = this->_internal_num();
  uint64_t raw_num;
  memcpy(&raw_num, &tmp_num, sizeof(tmp_num));
  if (raw_num != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_num(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:airmobisim.DoubleNumber)
  return target;
}

size_t DoubleNumber::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:airmobisim.DoubleNumber)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double num = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_num = this->_internal_num();
  uint64_t raw_num;
  memcpy(&raw_num, &tmp_num, sizeof(tmp_num));
  if (raw_num != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DoubleNumber::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DoubleNumber::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DoubleNumber::GetClassData() const { return &_class_data_; }


void DoubleNumber::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DoubleNumber*>(&to_msg);
  auto& from = static_cast<const DoubleNumber&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:airmobisim.DoubleNumber)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_num = from._internal_num();
  uint64_t raw_num;
  memcpy(&raw_num, &tmp_num, sizeof(tmp_num));
  if (raw_num != 0) {
    _this->_internal_set_num(from._internal_num());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DoubleNumber::CopyFrom(const DoubleNumber& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:airmobisim.DoubleNumber)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoubleNumber::IsInitialized() const {
  return true;
}

void DoubleNumber::InternalSwap(DoubleNumber* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.num_, other->_impl_.num_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DoubleNumber::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_airmobisim_2eproto_getter, &descriptor_table_airmobisim_2eproto_once,
      file_level_metadata_airmobisim_2eproto[9]);
}

// ===================================================================

class UavSetSpeed::_Internal {
 public:
};

UavSetSpeed::UavSetSpeed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:airmobisim.UavSetSpeed)
}
UavSetSpeed::UavSetSpeed(const UavSetSpeed& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UavSetSpeed* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.speed_){}
    , decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.speed_, &from._impl_.speed_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.id_) -
    reinterpret_cast<char*>(&_impl_.speed_)) + sizeof(_impl_.id_));
  // @@protoc_insertion_point(copy_constructor:airmobisim.UavSetSpeed)
}

inline void UavSetSpeed::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.speed_){0}
    , decltype(_impl_.id_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UavSetSpeed::~UavSetSpeed() {
  // @@protoc_insertion_point(destructor:airmobisim.UavSetSpeed)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UavSetSpeed::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UavSetSpeed::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UavSetSpeed::Clear() {
// @@protoc_insertion_point(message_clear_start:airmobisim.UavSetSpeed)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.speed_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.id_) -
      reinterpret_cast<char*>(&_impl_.speed_)) + sizeof(_impl_.id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UavSetSpeed::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double speed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UavSetSpeed::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:airmobisim.UavSetSpeed)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // double speed = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = this->_internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_speed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:airmobisim.UavSetSpeed)
  return target;
}

size_t UavSetSpeed::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:airmobisim.UavSetSpeed)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double speed = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = this->_internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    total_size += 1 + 8;
  }

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UavSetSpeed::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UavSetSpeed::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UavSetSpeed::GetClassData() const { return &_class_data_; }


void UavSetSpeed::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UavSetSpeed*>(&to_msg);
  auto& from = static_cast<const UavSetSpeed&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:airmobisim.UavSetSpeed)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = from._internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    _this->_internal_set_speed(from._internal_speed());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UavSetSpeed::CopyFrom(const UavSetSpeed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:airmobisim.UavSetSpeed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UavSetSpeed::IsInitialized() const {
  return true;
}

void UavSetSpeed::InternalSwap(UavSetSpeed* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UavSetSpeed, _impl_.id_)
      + sizeof(UavSetSpeed::_impl_.id_)
      - PROTOBUF_FIELD_OFFSET(UavSetSpeed, _impl_.speed_)>(
          reinterpret_cast<char*>(&_impl_.speed_),
          reinterpret_cast<char*>(&other->_impl_.speed_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UavSetSpeed::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_airmobisim_2eproto_getter, &descriptor_table_airmobisim_2eproto_once,
      file_level_metadata_airmobisim_2eproto[10]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace airmobisim
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::airmobisim::WaypointList*
Arena::CreateMaybeMessage< ::airmobisim::WaypointList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::airmobisim::WaypointList >(arena);
}
template<> PROTOBUF_NOINLINE ::airmobisim::Waypoint*
Arena::CreateMaybeMessage< ::airmobisim::Waypoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::airmobisim::Waypoint >(arena);
}
template<> PROTOBUF_NOINLINE ::airmobisim::UavList*
Arena::CreateMaybeMessage< ::airmobisim::UavList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::airmobisim::UavList >(arena);
}
template<> PROTOBUF_NOINLINE ::airmobisim::Uav*
Arena::CreateMaybeMessage< ::airmobisim::Uav >(Arena* arena) {
  return Arena::CreateMessageInternal< ::airmobisim::Uav >(arena);
}
template<> PROTOBUF_NOINLINE ::airmobisim::Response*
Arena::CreateMaybeMessage< ::airmobisim::Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::airmobisim::Response >(arena);
}
template<> PROTOBUF_NOINLINE ::airmobisim::ResponseQuery*
Arena::CreateMaybeMessage< ::airmobisim::ResponseQuery >(Arena* arena) {
  return Arena::CreateMessageInternal< ::airmobisim::ResponseQuery >(arena);
}
template<> PROTOBUF_NOINLINE ::airmobisim::StartUav*
Arena::CreateMaybeMessage< ::airmobisim::StartUav >(Arena* arena) {
  return Arena::CreateMessageInternal< ::airmobisim::StartUav >(arena);
}
template<> PROTOBUF_NOINLINE ::airmobisim::Coordinates*
Arena::CreateMaybeMessage< ::airmobisim::Coordinates >(Arena* arena) {
  return Arena::CreateMessageInternal< ::airmobisim::Coordinates >(arena);
}
template<> PROTOBUF_NOINLINE ::airmobisim::Number*
Arena::CreateMaybeMessage< ::airmobisim::Number >(Arena* arena) {
  return Arena::CreateMessageInternal< ::airmobisim::Number >(arena);
}
template<> PROTOBUF_NOINLINE ::airmobisim::DoubleNumber*
Arena::CreateMaybeMessage< ::airmobisim::DoubleNumber >(Arena* arena) {
  return Arena::CreateMessageInternal< ::airmobisim::DoubleNumber >(arena);
}
template<> PROTOBUF_NOINLINE ::airmobisim::UavSetSpeed*
Arena::CreateMaybeMessage< ::airmobisim::UavSetSpeed >(Arena* arena) {
  return Arena::CreateMessageInternal< ::airmobisim::UavSetSpeed >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
