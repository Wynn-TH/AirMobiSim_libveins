// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: airmobisim.proto
#ifndef GRPC_airmobisim_2eproto__INCLUDED
#define GRPC_airmobisim_2eproto__INCLUDED

#include "airmobisim.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace airmobisim {

class AirMobiSim final {
public:
    static constexpr char const* service_full_name()
    {
        return "airmobisim.AirMobiSim";
    }
    class StubInterface {
    public:
        virtual ~StubInterface() {}
        virtual ::grpc::Status Start(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncStart(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncStartRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncStart(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncStartRaw(context, request, cq));
        }
        virtual ::grpc::Status ExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::airmobisim::ResponseQuery* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::ResponseQuery>> AsyncExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::ResponseQuery>>(AsyncExecuteOneTimeStepRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::ResponseQuery>> PrepareAsyncExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::ResponseQuery>>(PrepareAsyncExecuteOneTimeStepRaw(context, request, cq));
        }
        virtual ::grpc::Status Finish(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncFinish(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncFinishRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncFinish(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncFinishRaw(context, request, cq));
        }
        virtual ::grpc::Status GetManagedHosts(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::airmobisim::UavList* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::UavList>> AsyncGetManagedHosts(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::UavList>>(AsyncGetManagedHostsRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::UavList>> PrepareAsyncGetManagedHosts(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::UavList>>(PrepareAsyncGetManagedHostsRaw(context, request, cq));
        }
        virtual ::grpc::Status InsertWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::google::protobuf::Empty* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncInsertWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncInsertWaypointsRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncInsertWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncInsertWaypointsRaw(context, request, cq));
        }
        virtual ::grpc::Status InsertWaypoint(::grpc::ClientContext* context, const ::airmobisim::Waypoint& request, ::google::protobuf::Empty* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncInsertWaypoint(::grpc::ClientContext* context, const ::airmobisim::Waypoint& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncInsertWaypointRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncInsertWaypoint(::grpc::ClientContext* context, const ::airmobisim::Waypoint& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncInsertWaypointRaw(context, request, cq));
        }
        virtual ::grpc::Status InsertUAV(::grpc::ClientContext* context, const ::airmobisim::StartUav& request, ::google::protobuf::Empty* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncInsertUAV(::grpc::ClientContext* context, const ::airmobisim::StartUav& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncInsertUAVRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncInsertUAV(::grpc::ClientContext* context, const ::airmobisim::StartUav& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncInsertUAVRaw(context, request, cq));
        }
        virtual ::grpc::Status getMaxUavId(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::airmobisim::Number* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::Number>> AsyncgetMaxUavId(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::Number>>(AsyncgetMaxUavIdRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::Number>> PrepareAsyncgetMaxUavId(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::Number>>(PrepareAsyncgetMaxUavIdRaw(context, request, cq));
        }
        virtual ::grpc::Status DeleteUAV(::grpc::ClientContext* context, const ::airmobisim::Number& request, ::google::protobuf::Empty* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncDeleteUAV(::grpc::ClientContext* context, const ::airmobisim::Number& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncDeleteUAVRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncDeleteUAV(::grpc::ClientContext* context, const ::airmobisim::Number& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncDeleteUAVRaw(context, request, cq));
        }
        virtual ::grpc::Status getNumberCurrentUAV(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::airmobisim::Number* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::Number>> AsyncgetNumberCurrentUAV(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::Number>>(AsyncgetNumberCurrentUAVRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::Number>> PrepareAsyncgetNumberCurrentUAV(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::Number>>(PrepareAsyncgetNumberCurrentUAVRaw(context, request, cq));
        }
        virtual ::grpc::Status SetDesiredSpeed(::grpc::ClientContext* context, const ::airmobisim::UavSetSpeed& request, ::google::protobuf::Empty* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncSetDesiredSpeed(::grpc::ClientContext* context, const ::airmobisim::UavSetSpeed& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncSetDesiredSpeedRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncSetDesiredSpeed(::grpc::ClientContext* context, const ::airmobisim::UavSetSpeed& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncSetDesiredSpeedRaw(context, request, cq));
        }
        virtual ::grpc::Status UpdateWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::google::protobuf::Empty* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncUpdateWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncUpdateWaypointsRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncUpdateWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncUpdateWaypointsRaw(context, request, cq));
        }
        virtual ::grpc::Status DeleteWaypoint(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::google::protobuf::Empty* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncDeleteWaypoint(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncDeleteWaypointRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncDeleteWaypoint(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncDeleteWaypointRaw(context, request, cq));
        }
        virtual ::grpc::Status GetMaxSimulationTime(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::airmobisim::Number* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::Number>> AsyncGetMaxSimulationTime(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::Number>>(AsyncGetMaxSimulationTimeRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::Number>> PrepareAsyncGetMaxSimulationTime(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::Number>>(PrepareAsyncGetMaxSimulationTimeRaw(context, request, cq));
        }
        virtual ::grpc::Status getMaxSimulationSteps(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::airmobisim::DoubleNumber* response) = 0;
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::DoubleNumber>> AsyncgetMaxSimulationSteps(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::DoubleNumber>>(AsyncgetMaxSimulationStepsRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::DoubleNumber>> PrepareAsyncgetMaxSimulationSteps(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::DoubleNumber>>(PrepareAsyncgetMaxSimulationStepsRaw(context, request, cq));
        }
        class experimental_async_interface {
        public:
            virtual ~experimental_async_interface() {}
            virtual void Start(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void Start(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void Start(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
            virtual void ExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::ResponseQuery* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void ExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::ResponseQuery* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void ExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::ResponseQuery* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
            virtual void Finish(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void Finish(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void Finish(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
            virtual void GetManagedHosts(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::UavList* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void GetManagedHosts(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::UavList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void GetManagedHosts(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::UavList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
            virtual void InsertWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void InsertWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void InsertWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
            virtual void InsertWaypoint(::grpc::ClientContext* context, const ::airmobisim::Waypoint* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void InsertWaypoint(::grpc::ClientContext* context, const ::airmobisim::Waypoint* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void InsertWaypoint(::grpc::ClientContext* context, const ::airmobisim::Waypoint* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
            virtual void InsertUAV(::grpc::ClientContext* context, const ::airmobisim::StartUav* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void InsertUAV(::grpc::ClientContext* context, const ::airmobisim::StartUav* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void InsertUAV(::grpc::ClientContext* context, const ::airmobisim::StartUav* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
            virtual void getMaxUavId(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void getMaxUavId(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void getMaxUavId(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
            virtual void DeleteUAV(::grpc::ClientContext* context, const ::airmobisim::Number* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void DeleteUAV(::grpc::ClientContext* context, const ::airmobisim::Number* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void DeleteUAV(::grpc::ClientContext* context, const ::airmobisim::Number* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
            virtual void getNumberCurrentUAV(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void getNumberCurrentUAV(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void getNumberCurrentUAV(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
            virtual void SetDesiredSpeed(::grpc::ClientContext* context, const ::airmobisim::UavSetSpeed* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void SetDesiredSpeed(::grpc::ClientContext* context, const ::airmobisim::UavSetSpeed* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void SetDesiredSpeed(::grpc::ClientContext* context, const ::airmobisim::UavSetSpeed* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
            virtual void UpdateWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void UpdateWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void UpdateWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
            virtual void DeleteWaypoint(::grpc::ClientContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void DeleteWaypoint(::grpc::ClientContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void DeleteWaypoint(::grpc::ClientContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
            virtual void GetMaxSimulationTime(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void GetMaxSimulationTime(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void GetMaxSimulationTime(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
            virtual void getMaxSimulationSteps(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::DoubleNumber* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            virtual void getMaxSimulationSteps(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::DoubleNumber* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
            virtual void getMaxSimulationSteps(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::DoubleNumber* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
        };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        async_interface* async() { return experimental_async(); }
    #endif
        virtual class experimental_async_interface* experimental_async() { return nullptr; }
    private:
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncStartRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncStartRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::ResponseQuery>* AsyncExecuteOneTimeStepRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::ResponseQuery>* PrepareAsyncExecuteOneTimeStepRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncFinishRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncFinishRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::UavList>* AsyncGetManagedHostsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::UavList>* PrepareAsyncGetManagedHostsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncInsertWaypointsRaw(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncInsertWaypointsRaw(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncInsertWaypointRaw(::grpc::ClientContext* context, const ::airmobisim::Waypoint& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncInsertWaypointRaw(::grpc::ClientContext* context, const ::airmobisim::Waypoint& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncInsertUAVRaw(::grpc::ClientContext* context, const ::airmobisim::StartUav& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncInsertUAVRaw(::grpc::ClientContext* context, const ::airmobisim::StartUav& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::Number>* AsyncgetMaxUavIdRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::Number>* PrepareAsyncgetMaxUavIdRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncDeleteUAVRaw(::grpc::ClientContext* context, const ::airmobisim::Number& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncDeleteUAVRaw(::grpc::ClientContext* context, const ::airmobisim::Number& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::Number>* AsyncgetNumberCurrentUAVRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::Number>* PrepareAsyncgetNumberCurrentUAVRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncSetDesiredSpeedRaw(::grpc::ClientContext* context, const ::airmobisim::UavSetSpeed& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncSetDesiredSpeedRaw(::grpc::ClientContext* context, const ::airmobisim::UavSetSpeed& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncUpdateWaypointsRaw(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncUpdateWaypointsRaw(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncDeleteWaypointRaw(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncDeleteWaypointRaw(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::Number>* AsyncGetMaxSimulationTimeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::Number>* PrepareAsyncGetMaxSimulationTimeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::DoubleNumber>* AsyncgetMaxSimulationStepsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
        virtual ::grpc::ClientAsyncResponseReaderInterface< ::airmobisim::DoubleNumber>* PrepareAsyncgetMaxSimulationStepsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    };
    class Stub final : public StubInterface {
    public:
        Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
        ::grpc::Status Start(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncStart(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncStartRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncStart(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncStartRaw(context, request, cq));
        }
        ::grpc::Status ExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::airmobisim::ResponseQuery* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::ResponseQuery>> AsyncExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::ResponseQuery>>(AsyncExecuteOneTimeStepRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::ResponseQuery>> PrepareAsyncExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::ResponseQuery>>(PrepareAsyncExecuteOneTimeStepRaw(context, request, cq));
        }
        ::grpc::Status Finish(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncFinish(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncFinishRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncFinish(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncFinishRaw(context, request, cq));
        }
        ::grpc::Status GetManagedHosts(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::airmobisim::UavList* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::UavList>> AsyncGetManagedHosts(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::UavList>>(AsyncGetManagedHostsRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::UavList>> PrepareAsyncGetManagedHosts(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::UavList>>(PrepareAsyncGetManagedHostsRaw(context, request, cq));
        }
        ::grpc::Status InsertWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::google::protobuf::Empty* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncInsertWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncInsertWaypointsRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncInsertWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncInsertWaypointsRaw(context, request, cq));
        }
        ::grpc::Status InsertWaypoint(::grpc::ClientContext* context, const ::airmobisim::Waypoint& request, ::google::protobuf::Empty* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncInsertWaypoint(::grpc::ClientContext* context, const ::airmobisim::Waypoint& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncInsertWaypointRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncInsertWaypoint(::grpc::ClientContext* context, const ::airmobisim::Waypoint& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncInsertWaypointRaw(context, request, cq));
        }
        ::grpc::Status InsertUAV(::grpc::ClientContext* context, const ::airmobisim::StartUav& request, ::google::protobuf::Empty* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncInsertUAV(::grpc::ClientContext* context, const ::airmobisim::StartUav& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncInsertUAVRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncInsertUAV(::grpc::ClientContext* context, const ::airmobisim::StartUav& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncInsertUAVRaw(context, request, cq));
        }
        ::grpc::Status getMaxUavId(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::airmobisim::Number* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::Number>> AsyncgetMaxUavId(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::Number>>(AsyncgetMaxUavIdRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::Number>> PrepareAsyncgetMaxUavId(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::Number>>(PrepareAsyncgetMaxUavIdRaw(context, request, cq));
        }
        ::grpc::Status DeleteUAV(::grpc::ClientContext* context, const ::airmobisim::Number& request, ::google::protobuf::Empty* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncDeleteUAV(::grpc::ClientContext* context, const ::airmobisim::Number& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncDeleteUAVRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncDeleteUAV(::grpc::ClientContext* context, const ::airmobisim::Number& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncDeleteUAVRaw(context, request, cq));
        }
        ::grpc::Status getNumberCurrentUAV(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::airmobisim::Number* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::Number>> AsyncgetNumberCurrentUAV(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::Number>>(AsyncgetNumberCurrentUAVRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::Number>> PrepareAsyncgetNumberCurrentUAV(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::Number>>(PrepareAsyncgetNumberCurrentUAVRaw(context, request, cq));
        }
        ::grpc::Status SetDesiredSpeed(::grpc::ClientContext* context, const ::airmobisim::UavSetSpeed& request, ::google::protobuf::Empty* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncSetDesiredSpeed(::grpc::ClientContext* context, const ::airmobisim::UavSetSpeed& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncSetDesiredSpeedRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncSetDesiredSpeed(::grpc::ClientContext* context, const ::airmobisim::UavSetSpeed& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncSetDesiredSpeedRaw(context, request, cq));
        }
        ::grpc::Status UpdateWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::google::protobuf::Empty* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncUpdateWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncUpdateWaypointsRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncUpdateWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncUpdateWaypointsRaw(context, request, cq));
        }
        ::grpc::Status DeleteWaypoint(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::google::protobuf::Empty* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncDeleteWaypoint(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncDeleteWaypointRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncDeleteWaypoint(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncDeleteWaypointRaw(context, request, cq));
        }
        ::grpc::Status GetMaxSimulationTime(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::airmobisim::Number* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::Number>> AsyncGetMaxSimulationTime(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::Number>>(AsyncGetMaxSimulationTimeRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::Number>> PrepareAsyncGetMaxSimulationTime(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::Number>>(PrepareAsyncGetMaxSimulationTimeRaw(context, request, cq));
        }
        ::grpc::Status getMaxSimulationSteps(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::airmobisim::DoubleNumber* response) override;
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::DoubleNumber>> AsyncgetMaxSimulationSteps(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::DoubleNumber>>(AsyncgetMaxSimulationStepsRaw(context, request, cq));
        }
        std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::DoubleNumber>> PrepareAsyncgetMaxSimulationSteps(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq)
        {
            return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::airmobisim::DoubleNumber>>(PrepareAsyncgetMaxSimulationStepsRaw(context, request, cq));
        }
        class experimental_async final :
            public StubInterface::experimental_async_interface {
        public:
            void Start(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void Start(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void Start(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
            void ExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::ResponseQuery* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void ExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::ResponseQuery* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void ExecuteOneTimeStep(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::ResponseQuery* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
            void Finish(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void Finish(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void Finish(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
            void GetManagedHosts(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::UavList* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void GetManagedHosts(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::UavList* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void GetManagedHosts(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::UavList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
            void InsertWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void InsertWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void InsertWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
            void InsertWaypoint(::grpc::ClientContext* context, const ::airmobisim::Waypoint* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void InsertWaypoint(::grpc::ClientContext* context, const ::airmobisim::Waypoint* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void InsertWaypoint(::grpc::ClientContext* context, const ::airmobisim::Waypoint* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
            void InsertUAV(::grpc::ClientContext* context, const ::airmobisim::StartUav* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void InsertUAV(::grpc::ClientContext* context, const ::airmobisim::StartUav* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void InsertUAV(::grpc::ClientContext* context, const ::airmobisim::StartUav* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
            void getMaxUavId(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void getMaxUavId(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void getMaxUavId(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
            void DeleteUAV(::grpc::ClientContext* context, const ::airmobisim::Number* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void DeleteUAV(::grpc::ClientContext* context, const ::airmobisim::Number* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void DeleteUAV(::grpc::ClientContext* context, const ::airmobisim::Number* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
            void getNumberCurrentUAV(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void getNumberCurrentUAV(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void getNumberCurrentUAV(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
            void SetDesiredSpeed(::grpc::ClientContext* context, const ::airmobisim::UavSetSpeed* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void SetDesiredSpeed(::grpc::ClientContext* context, const ::airmobisim::UavSetSpeed* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void SetDesiredSpeed(::grpc::ClientContext* context, const ::airmobisim::UavSetSpeed* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
            void UpdateWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void UpdateWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void UpdateWaypoints(::grpc::ClientContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
            void DeleteWaypoint(::grpc::ClientContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void DeleteWaypoint(::grpc::ClientContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void DeleteWaypoint(::grpc::ClientContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
            void GetMaxSimulationTime(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void GetMaxSimulationTime(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void GetMaxSimulationTime(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
            void getMaxSimulationSteps(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::DoubleNumber* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            void getMaxSimulationSteps(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::DoubleNumber* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
            void getMaxSimulationSteps(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::airmobisim::DoubleNumber* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
        private:
            friend class Stub;
            explicit experimental_async(Stub* stub)
                : stub_(stub) { }
            Stub* stub() { return stub_; }
            Stub* stub_;
        };
        class experimental_async_interface* experimental_async() override { return &async_stub_; }

    private:
        std::shared_ptr< ::grpc::ChannelInterface> channel_;
        class experimental_async async_stub_ {
            this
        };
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncStartRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncStartRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::airmobisim::ResponseQuery>* AsyncExecuteOneTimeStepRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::airmobisim::ResponseQuery>* PrepareAsyncExecuteOneTimeStepRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncFinishRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncFinishRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::airmobisim::UavList>* AsyncGetManagedHostsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::airmobisim::UavList>* PrepareAsyncGetManagedHostsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncInsertWaypointsRaw(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncInsertWaypointsRaw(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncInsertWaypointRaw(::grpc::ClientContext* context, const ::airmobisim::Waypoint& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncInsertWaypointRaw(::grpc::ClientContext* context, const ::airmobisim::Waypoint& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncInsertUAVRaw(::grpc::ClientContext* context, const ::airmobisim::StartUav& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncInsertUAVRaw(::grpc::ClientContext* context, const ::airmobisim::StartUav& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::airmobisim::Number>* AsyncgetMaxUavIdRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::airmobisim::Number>* PrepareAsyncgetMaxUavIdRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncDeleteUAVRaw(::grpc::ClientContext* context, const ::airmobisim::Number& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncDeleteUAVRaw(::grpc::ClientContext* context, const ::airmobisim::Number& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::airmobisim::Number>* AsyncgetNumberCurrentUAVRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::airmobisim::Number>* PrepareAsyncgetNumberCurrentUAVRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncSetDesiredSpeedRaw(::grpc::ClientContext* context, const ::airmobisim::UavSetSpeed& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncSetDesiredSpeedRaw(::grpc::ClientContext* context, const ::airmobisim::UavSetSpeed& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncUpdateWaypointsRaw(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncUpdateWaypointsRaw(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncDeleteWaypointRaw(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncDeleteWaypointRaw(::grpc::ClientContext* context, const ::airmobisim::WaypointList& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::airmobisim::Number>* AsyncGetMaxSimulationTimeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::airmobisim::Number>* PrepareAsyncGetMaxSimulationTimeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::airmobisim::DoubleNumber>* AsyncgetMaxSimulationStepsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        ::grpc::ClientAsyncResponseReader< ::airmobisim::DoubleNumber>* PrepareAsyncgetMaxSimulationStepsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
        const ::grpc::internal::RpcMethod rpcmethod_Start_;
        const ::grpc::internal::RpcMethod rpcmethod_ExecuteOneTimeStep_;
        const ::grpc::internal::RpcMethod rpcmethod_Finish_;
        const ::grpc::internal::RpcMethod rpcmethod_GetManagedHosts_;
        const ::grpc::internal::RpcMethod rpcmethod_InsertWaypoints_;
        const ::grpc::internal::RpcMethod rpcmethod_InsertWaypoint_;
        const ::grpc::internal::RpcMethod rpcmethod_InsertUAV_;
        const ::grpc::internal::RpcMethod rpcmethod_getMaxUavId_;
        const ::grpc::internal::RpcMethod rpcmethod_DeleteUAV_;
        const ::grpc::internal::RpcMethod rpcmethod_getNumberCurrentUAV_;
        const ::grpc::internal::RpcMethod rpcmethod_SetDesiredSpeed_;
        const ::grpc::internal::RpcMethod rpcmethod_UpdateWaypoints_;
        const ::grpc::internal::RpcMethod rpcmethod_DeleteWaypoint_;
        const ::grpc::internal::RpcMethod rpcmethod_GetMaxSimulationTime_;
        const ::grpc::internal::RpcMethod rpcmethod_getMaxSimulationSteps_;
    };
    static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

    class Service : public ::grpc::Service {
    public:
        Service();
        virtual ~Service();
        virtual ::grpc::Status Start(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response);
        virtual ::grpc::Status ExecuteOneTimeStep(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::airmobisim::ResponseQuery* response);
        virtual ::grpc::Status Finish(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response);
        virtual ::grpc::Status GetManagedHosts(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::airmobisim::UavList* response);
        virtual ::grpc::Status InsertWaypoints(::grpc::ServerContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response);
        virtual ::grpc::Status InsertWaypoint(::grpc::ServerContext* context, const ::airmobisim::Waypoint* request, ::google::protobuf::Empty* response);
        virtual ::grpc::Status InsertUAV(::grpc::ServerContext* context, const ::airmobisim::StartUav* request, ::google::protobuf::Empty* response);
        virtual ::grpc::Status getMaxUavId(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response);
        virtual ::grpc::Status DeleteUAV(::grpc::ServerContext* context, const ::airmobisim::Number* request, ::google::protobuf::Empty* response);
        virtual ::grpc::Status getNumberCurrentUAV(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response);
        virtual ::grpc::Status SetDesiredSpeed(::grpc::ServerContext* context, const ::airmobisim::UavSetSpeed* request, ::google::protobuf::Empty* response);
        virtual ::grpc::Status UpdateWaypoints(::grpc::ServerContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response);
        virtual ::grpc::Status DeleteWaypoint(::grpc::ServerContext* context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response);
        virtual ::grpc::Status GetMaxSimulationTime(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response);
        virtual ::grpc::Status getMaxSimulationSteps(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::airmobisim::DoubleNumber* response);
    };
    template <class BaseClass>
    class WithAsyncMethod_Start : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_Start()
        {
            ::grpc::Service::MarkMethodAsync(0);
        }
        ~WithAsyncMethod_Start() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status Start(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestStart(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_ExecuteOneTimeStep : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_ExecuteOneTimeStep()
        {
            ::grpc::Service::MarkMethodAsync(1);
        }
        ~WithAsyncMethod_ExecuteOneTimeStep() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status ExecuteOneTimeStep(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::ResponseQuery* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestExecuteOneTimeStep(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::airmobisim::ResponseQuery>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_Finish : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_Finish()
        {
            ::grpc::Service::MarkMethodAsync(2);
        }
        ~WithAsyncMethod_Finish() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status Finish(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestFinish(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_GetManagedHosts : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_GetManagedHosts()
        {
            ::grpc::Service::MarkMethodAsync(3);
        }
        ~WithAsyncMethod_GetManagedHosts() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetManagedHosts(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::UavList* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestGetManagedHosts(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::airmobisim::UavList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_InsertWaypoints : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_InsertWaypoints()
        {
            ::grpc::Service::MarkMethodAsync(4);
        }
        ~WithAsyncMethod_InsertWaypoints() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status InsertWaypoints(::grpc::ServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestInsertWaypoints(::grpc::ServerContext* context, ::airmobisim::WaypointList* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_InsertWaypoint : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_InsertWaypoint()
        {
            ::grpc::Service::MarkMethodAsync(5);
        }
        ~WithAsyncMethod_InsertWaypoint() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status InsertWaypoint(::grpc::ServerContext* /*context*/, const ::airmobisim::Waypoint* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestInsertWaypoint(::grpc::ServerContext* context, ::airmobisim::Waypoint* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_InsertUAV : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_InsertUAV()
        {
            ::grpc::Service::MarkMethodAsync(6);
        }
        ~WithAsyncMethod_InsertUAV() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status InsertUAV(::grpc::ServerContext* /*context*/, const ::airmobisim::StartUav* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestInsertUAV(::grpc::ServerContext* context, ::airmobisim::StartUav* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_getMaxUavId : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_getMaxUavId()
        {
            ::grpc::Service::MarkMethodAsync(7);
        }
        ~WithAsyncMethod_getMaxUavId() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status getMaxUavId(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestgetMaxUavId(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::airmobisim::Number>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_DeleteUAV : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_DeleteUAV()
        {
            ::grpc::Service::MarkMethodAsync(8);
        }
        ~WithAsyncMethod_DeleteUAV() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status DeleteUAV(::grpc::ServerContext* /*context*/, const ::airmobisim::Number* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestDeleteUAV(::grpc::ServerContext* context, ::airmobisim::Number* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_getNumberCurrentUAV : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_getNumberCurrentUAV()
        {
            ::grpc::Service::MarkMethodAsync(9);
        }
        ~WithAsyncMethod_getNumberCurrentUAV() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status getNumberCurrentUAV(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestgetNumberCurrentUAV(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::airmobisim::Number>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_SetDesiredSpeed : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_SetDesiredSpeed()
        {
            ::grpc::Service::MarkMethodAsync(10);
        }
        ~WithAsyncMethod_SetDesiredSpeed() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status SetDesiredSpeed(::grpc::ServerContext* /*context*/, const ::airmobisim::UavSetSpeed* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestSetDesiredSpeed(::grpc::ServerContext* context, ::airmobisim::UavSetSpeed* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_UpdateWaypoints : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_UpdateWaypoints()
        {
            ::grpc::Service::MarkMethodAsync(11);
        }
        ~WithAsyncMethod_UpdateWaypoints() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status UpdateWaypoints(::grpc::ServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestUpdateWaypoints(::grpc::ServerContext* context, ::airmobisim::WaypointList* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_DeleteWaypoint : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_DeleteWaypoint()
        {
            ::grpc::Service::MarkMethodAsync(12);
        }
        ~WithAsyncMethod_DeleteWaypoint() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status DeleteWaypoint(::grpc::ServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestDeleteWaypoint(::grpc::ServerContext* context, ::airmobisim::WaypointList* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_GetMaxSimulationTime : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_GetMaxSimulationTime()
        {
            ::grpc::Service::MarkMethodAsync(13);
        }
        ~WithAsyncMethod_GetMaxSimulationTime() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetMaxSimulationTime(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestGetMaxSimulationTime(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::airmobisim::Number>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithAsyncMethod_getMaxSimulationSteps : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithAsyncMethod_getMaxSimulationSteps()
        {
            ::grpc::Service::MarkMethodAsync(14);
        }
        ~WithAsyncMethod_getMaxSimulationSteps() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status getMaxSimulationSteps(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::DoubleNumber* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestgetMaxSimulationSteps(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::airmobisim::DoubleNumber>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    typedef WithAsyncMethod_Start<WithAsyncMethod_ExecuteOneTimeStep<WithAsyncMethod_Finish<WithAsyncMethod_GetManagedHosts<WithAsyncMethod_InsertWaypoints<WithAsyncMethod_InsertWaypoint<WithAsyncMethod_InsertUAV<WithAsyncMethod_getMaxUavId<WithAsyncMethod_DeleteUAV<WithAsyncMethod_getNumberCurrentUAV<WithAsyncMethod_SetDesiredSpeed<WithAsyncMethod_UpdateWaypoints<WithAsyncMethod_DeleteWaypoint<WithAsyncMethod_GetMaxSimulationTime<WithAsyncMethod_getMaxSimulationSteps<Service>>>>>>>>>>>>>>> AsyncService;
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_Start : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_Start()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(0,
                new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response) { return this->Start(context, request, response); }));
        }
        void SetMessageAllocatorFor_Start(
            ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::google::protobuf::Empty>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_Start() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status Start(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* Start(
            ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* Start(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_ExecuteOneTimeStep : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_ExecuteOneTimeStep()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(1,
                new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::airmobisim::ResponseQuery>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::google::protobuf::Empty* request, ::airmobisim::ResponseQuery* response) { return this->ExecuteOneTimeStep(context, request, response); }));
        }
        void SetMessageAllocatorFor_ExecuteOneTimeStep(
            ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::airmobisim::ResponseQuery>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::airmobisim::ResponseQuery>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_ExecuteOneTimeStep() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status ExecuteOneTimeStep(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::ResponseQuery* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* ExecuteOneTimeStep(
            ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::ResponseQuery* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* ExecuteOneTimeStep(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::ResponseQuery* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_Finish : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_Finish()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(2,
                new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response) { return this->Finish(context, request, response); }));
        }
        void SetMessageAllocatorFor_Finish(
            ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::google::protobuf::Empty>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_Finish() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status Finish(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* Finish(
            ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* Finish(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_GetManagedHosts : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_GetManagedHosts()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(3,
                new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::airmobisim::UavList>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::google::protobuf::Empty* request, ::airmobisim::UavList* response) { return this->GetManagedHosts(context, request, response); }));
        }
        void SetMessageAllocatorFor_GetManagedHosts(
            ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::airmobisim::UavList>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::airmobisim::UavList>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_GetManagedHosts() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetManagedHosts(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::UavList* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* GetManagedHosts(
            ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::UavList* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* GetManagedHosts(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::UavList* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_InsertWaypoints : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_InsertWaypoints()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(4,
                new ::grpc::internal::CallbackUnaryHandler< ::airmobisim::WaypointList, ::google::protobuf::Empty>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response) { return this->InsertWaypoints(context, request, response); }));
        }
        void SetMessageAllocatorFor_InsertWaypoints(
            ::grpc::experimental::MessageAllocator< ::airmobisim::WaypointList, ::google::protobuf::Empty>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::airmobisim::WaypointList, ::google::protobuf::Empty>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_InsertWaypoints() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status InsertWaypoints(::grpc::ServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* InsertWaypoints(
            ::grpc::CallbackServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* InsertWaypoints(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_InsertWaypoint : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_InsertWaypoint()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(5,
                new ::grpc::internal::CallbackUnaryHandler< ::airmobisim::Waypoint, ::google::protobuf::Empty>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::airmobisim::Waypoint* request, ::google::protobuf::Empty* response) { return this->InsertWaypoint(context, request, response); }));
        }
        void SetMessageAllocatorFor_InsertWaypoint(
            ::grpc::experimental::MessageAllocator< ::airmobisim::Waypoint, ::google::protobuf::Empty>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::airmobisim::Waypoint, ::google::protobuf::Empty>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_InsertWaypoint() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status InsertWaypoint(::grpc::ServerContext* /*context*/, const ::airmobisim::Waypoint* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* InsertWaypoint(
            ::grpc::CallbackServerContext* /*context*/, const ::airmobisim::Waypoint* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* InsertWaypoint(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::airmobisim::Waypoint* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_InsertUAV : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_InsertUAV()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(6,
                new ::grpc::internal::CallbackUnaryHandler< ::airmobisim::StartUav, ::google::protobuf::Empty>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::airmobisim::StartUav* request, ::google::protobuf::Empty* response) { return this->InsertUAV(context, request, response); }));
        }
        void SetMessageAllocatorFor_InsertUAV(
            ::grpc::experimental::MessageAllocator< ::airmobisim::StartUav, ::google::protobuf::Empty>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::airmobisim::StartUav, ::google::protobuf::Empty>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_InsertUAV() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status InsertUAV(::grpc::ServerContext* /*context*/, const ::airmobisim::StartUav* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* InsertUAV(
            ::grpc::CallbackServerContext* /*context*/, const ::airmobisim::StartUav* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* InsertUAV(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::airmobisim::StartUav* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_getMaxUavId : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_getMaxUavId()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(7,
                new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::airmobisim::Number>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response) { return this->getMaxUavId(context, request, response); }));
        }
        void SetMessageAllocatorFor_getMaxUavId(
            ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::airmobisim::Number>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::airmobisim::Number>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_getMaxUavId() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status getMaxUavId(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* getMaxUavId(
            ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* getMaxUavId(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_DeleteUAV : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_DeleteUAV()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(8,
                new ::grpc::internal::CallbackUnaryHandler< ::airmobisim::Number, ::google::protobuf::Empty>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::airmobisim::Number* request, ::google::protobuf::Empty* response) { return this->DeleteUAV(context, request, response); }));
        }
        void SetMessageAllocatorFor_DeleteUAV(
            ::grpc::experimental::MessageAllocator< ::airmobisim::Number, ::google::protobuf::Empty>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::airmobisim::Number, ::google::protobuf::Empty>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_DeleteUAV() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status DeleteUAV(::grpc::ServerContext* /*context*/, const ::airmobisim::Number* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* DeleteUAV(
            ::grpc::CallbackServerContext* /*context*/, const ::airmobisim::Number* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* DeleteUAV(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::airmobisim::Number* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_getNumberCurrentUAV : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_getNumberCurrentUAV()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(9,
                new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::airmobisim::Number>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response) { return this->getNumberCurrentUAV(context, request, response); }));
        }
        void SetMessageAllocatorFor_getNumberCurrentUAV(
            ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::airmobisim::Number>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::airmobisim::Number>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_getNumberCurrentUAV() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status getNumberCurrentUAV(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* getNumberCurrentUAV(
            ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* getNumberCurrentUAV(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_SetDesiredSpeed : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_SetDesiredSpeed()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(10,
                new ::grpc::internal::CallbackUnaryHandler< ::airmobisim::UavSetSpeed, ::google::protobuf::Empty>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::airmobisim::UavSetSpeed* request, ::google::protobuf::Empty* response) { return this->SetDesiredSpeed(context, request, response); }));
        }
        void SetMessageAllocatorFor_SetDesiredSpeed(
            ::grpc::experimental::MessageAllocator< ::airmobisim::UavSetSpeed, ::google::protobuf::Empty>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::airmobisim::UavSetSpeed, ::google::protobuf::Empty>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_SetDesiredSpeed() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status SetDesiredSpeed(::grpc::ServerContext* /*context*/, const ::airmobisim::UavSetSpeed* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* SetDesiredSpeed(
            ::grpc::CallbackServerContext* /*context*/, const ::airmobisim::UavSetSpeed* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* SetDesiredSpeed(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::airmobisim::UavSetSpeed* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_UpdateWaypoints : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_UpdateWaypoints()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(11,
                new ::grpc::internal::CallbackUnaryHandler< ::airmobisim::WaypointList, ::google::protobuf::Empty>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response) { return this->UpdateWaypoints(context, request, response); }));
        }
        void SetMessageAllocatorFor_UpdateWaypoints(
            ::grpc::experimental::MessageAllocator< ::airmobisim::WaypointList, ::google::protobuf::Empty>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::airmobisim::WaypointList, ::google::protobuf::Empty>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_UpdateWaypoints() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status UpdateWaypoints(::grpc::ServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* UpdateWaypoints(
            ::grpc::CallbackServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* UpdateWaypoints(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_DeleteWaypoint : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_DeleteWaypoint()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(12,
                new ::grpc::internal::CallbackUnaryHandler< ::airmobisim::WaypointList, ::google::protobuf::Empty>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::airmobisim::WaypointList* request, ::google::protobuf::Empty* response) { return this->DeleteWaypoint(context, request, response); }));
        }
        void SetMessageAllocatorFor_DeleteWaypoint(
            ::grpc::experimental::MessageAllocator< ::airmobisim::WaypointList, ::google::protobuf::Empty>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::airmobisim::WaypointList, ::google::protobuf::Empty>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_DeleteWaypoint() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status DeleteWaypoint(::grpc::ServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* DeleteWaypoint(
            ::grpc::CallbackServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* DeleteWaypoint(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_GetMaxSimulationTime : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_GetMaxSimulationTime()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(13,
                new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::airmobisim::Number>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::google::protobuf::Empty* request, ::airmobisim::Number* response) { return this->GetMaxSimulationTime(context, request, response); }));
        }
        void SetMessageAllocatorFor_GetMaxSimulationTime(
            ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::airmobisim::Number>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::airmobisim::Number>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_GetMaxSimulationTime() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetMaxSimulationTime(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* GetMaxSimulationTime(
            ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* GetMaxSimulationTime(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithCallbackMethod_getMaxSimulationSteps : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithCallbackMethod_getMaxSimulationSteps()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodCallback(14,
                new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::airmobisim::DoubleNumber>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::google::protobuf::Empty* request, ::airmobisim::DoubleNumber* response) { return this->getMaxSimulationSteps(context, request, response); }));
        }
        void SetMessageAllocatorFor_getMaxSimulationSteps(
            ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::airmobisim::DoubleNumber>* allocator)
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
            ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
            static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::airmobisim::DoubleNumber>*>(handler)
            ->SetMessageAllocator(allocator);
        }
        ~ExperimentalWithCallbackMethod_getMaxSimulationSteps() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status getMaxSimulationSteps(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::DoubleNumber* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* getMaxSimulationSteps(
            ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::DoubleNumber* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* getMaxSimulationSteps(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::DoubleNumber* /*response*/)
    #endif
        { return nullptr; }
    };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef ExperimentalWithCallbackMethod_Start<ExperimentalWithCallbackMethod_ExecuteOneTimeStep<ExperimentalWithCallbackMethod_Finish<ExperimentalWithCallbackMethod_GetManagedHosts<ExperimentalWithCallbackMethod_InsertWaypoints<ExperimentalWithCallbackMethod_InsertWaypoint<ExperimentalWithCallbackMethod_InsertUAV<ExperimentalWithCallbackMethod_getMaxUavId<ExperimentalWithCallbackMethod_DeleteUAV<ExperimentalWithCallbackMethod_getNumberCurrentUAV<ExperimentalWithCallbackMethod_SetDesiredSpeed<ExperimentalWithCallbackMethod_UpdateWaypoints<ExperimentalWithCallbackMethod_DeleteWaypoint<ExperimentalWithCallbackMethod_GetMaxSimulationTime<ExperimentalWithCallbackMethod_getMaxSimulationSteps<Service>>>>>>>>>>>>>>> CallbackService;
  #endif

    typedef ExperimentalWithCallbackMethod_Start<ExperimentalWithCallbackMethod_ExecuteOneTimeStep<ExperimentalWithCallbackMethod_Finish<ExperimentalWithCallbackMethod_GetManagedHosts<ExperimentalWithCallbackMethod_InsertWaypoints<ExperimentalWithCallbackMethod_InsertWaypoint<ExperimentalWithCallbackMethod_InsertUAV<ExperimentalWithCallbackMethod_getMaxUavId<ExperimentalWithCallbackMethod_DeleteUAV<ExperimentalWithCallbackMethod_getNumberCurrentUAV<ExperimentalWithCallbackMethod_SetDesiredSpeed<ExperimentalWithCallbackMethod_UpdateWaypoints<ExperimentalWithCallbackMethod_DeleteWaypoint<ExperimentalWithCallbackMethod_GetMaxSimulationTime<ExperimentalWithCallbackMethod_getMaxSimulationSteps<Service>>>>>>>>>>>>>>> ExperimentalCallbackService;
    template <class BaseClass>
    class WithGenericMethod_Start : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_Start()
        {
            ::grpc::Service::MarkMethodGeneric(0);
        }
        ~WithGenericMethod_Start() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status Start(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_ExecuteOneTimeStep : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_ExecuteOneTimeStep()
        {
            ::grpc::Service::MarkMethodGeneric(1);
        }
        ~WithGenericMethod_ExecuteOneTimeStep() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status ExecuteOneTimeStep(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::ResponseQuery* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_Finish : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_Finish()
        {
            ::grpc::Service::MarkMethodGeneric(2);
        }
        ~WithGenericMethod_Finish() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status Finish(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_GetManagedHosts : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_GetManagedHosts()
        {
            ::grpc::Service::MarkMethodGeneric(3);
        }
        ~WithGenericMethod_GetManagedHosts() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetManagedHosts(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::UavList* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_InsertWaypoints : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_InsertWaypoints()
        {
            ::grpc::Service::MarkMethodGeneric(4);
        }
        ~WithGenericMethod_InsertWaypoints() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status InsertWaypoints(::grpc::ServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_InsertWaypoint : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_InsertWaypoint()
        {
            ::grpc::Service::MarkMethodGeneric(5);
        }
        ~WithGenericMethod_InsertWaypoint() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status InsertWaypoint(::grpc::ServerContext* /*context*/, const ::airmobisim::Waypoint* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_InsertUAV : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_InsertUAV()
        {
            ::grpc::Service::MarkMethodGeneric(6);
        }
        ~WithGenericMethod_InsertUAV() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status InsertUAV(::grpc::ServerContext* /*context*/, const ::airmobisim::StartUav* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_getMaxUavId : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_getMaxUavId()
        {
            ::grpc::Service::MarkMethodGeneric(7);
        }
        ~WithGenericMethod_getMaxUavId() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status getMaxUavId(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_DeleteUAV : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_DeleteUAV()
        {
            ::grpc::Service::MarkMethodGeneric(8);
        }
        ~WithGenericMethod_DeleteUAV() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status DeleteUAV(::grpc::ServerContext* /*context*/, const ::airmobisim::Number* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_getNumberCurrentUAV : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_getNumberCurrentUAV()
        {
            ::grpc::Service::MarkMethodGeneric(9);
        }
        ~WithGenericMethod_getNumberCurrentUAV() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status getNumberCurrentUAV(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_SetDesiredSpeed : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_SetDesiredSpeed()
        {
            ::grpc::Service::MarkMethodGeneric(10);
        }
        ~WithGenericMethod_SetDesiredSpeed() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status SetDesiredSpeed(::grpc::ServerContext* /*context*/, const ::airmobisim::UavSetSpeed* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_UpdateWaypoints : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_UpdateWaypoints()
        {
            ::grpc::Service::MarkMethodGeneric(11);
        }
        ~WithGenericMethod_UpdateWaypoints() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status UpdateWaypoints(::grpc::ServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_DeleteWaypoint : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_DeleteWaypoint()
        {
            ::grpc::Service::MarkMethodGeneric(12);
        }
        ~WithGenericMethod_DeleteWaypoint() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status DeleteWaypoint(::grpc::ServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_GetMaxSimulationTime : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_GetMaxSimulationTime()
        {
            ::grpc::Service::MarkMethodGeneric(13);
        }
        ~WithGenericMethod_GetMaxSimulationTime() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetMaxSimulationTime(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithGenericMethod_getMaxSimulationSteps : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithGenericMethod_getMaxSimulationSteps()
        {
            ::grpc::Service::MarkMethodGeneric(14);
        }
        ~WithGenericMethod_getMaxSimulationSteps() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status getMaxSimulationSteps(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::DoubleNumber* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };
    template <class BaseClass>
    class WithRawMethod_Start : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_Start()
        {
            ::grpc::Service::MarkMethodRaw(0);
        }
        ~WithRawMethod_Start() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status Start(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestStart(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_ExecuteOneTimeStep : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_ExecuteOneTimeStep()
        {
            ::grpc::Service::MarkMethodRaw(1);
        }
        ~WithRawMethod_ExecuteOneTimeStep() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status ExecuteOneTimeStep(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::ResponseQuery* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestExecuteOneTimeStep(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_Finish : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_Finish()
        {
            ::grpc::Service::MarkMethodRaw(2);
        }
        ~WithRawMethod_Finish() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status Finish(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestFinish(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_GetManagedHosts : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_GetManagedHosts()
        {
            ::grpc::Service::MarkMethodRaw(3);
        }
        ~WithRawMethod_GetManagedHosts() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetManagedHosts(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::UavList* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestGetManagedHosts(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_InsertWaypoints : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_InsertWaypoints()
        {
            ::grpc::Service::MarkMethodRaw(4);
        }
        ~WithRawMethod_InsertWaypoints() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status InsertWaypoints(::grpc::ServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestInsertWaypoints(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_InsertWaypoint : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_InsertWaypoint()
        {
            ::grpc::Service::MarkMethodRaw(5);
        }
        ~WithRawMethod_InsertWaypoint() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status InsertWaypoint(::grpc::ServerContext* /*context*/, const ::airmobisim::Waypoint* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestInsertWaypoint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_InsertUAV : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_InsertUAV()
        {
            ::grpc::Service::MarkMethodRaw(6);
        }
        ~WithRawMethod_InsertUAV() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status InsertUAV(::grpc::ServerContext* /*context*/, const ::airmobisim::StartUav* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestInsertUAV(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_getMaxUavId : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_getMaxUavId()
        {
            ::grpc::Service::MarkMethodRaw(7);
        }
        ~WithRawMethod_getMaxUavId() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status getMaxUavId(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestgetMaxUavId(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_DeleteUAV : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_DeleteUAV()
        {
            ::grpc::Service::MarkMethodRaw(8);
        }
        ~WithRawMethod_DeleteUAV() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status DeleteUAV(::grpc::ServerContext* /*context*/, const ::airmobisim::Number* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestDeleteUAV(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_getNumberCurrentUAV : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_getNumberCurrentUAV()
        {
            ::grpc::Service::MarkMethodRaw(9);
        }
        ~WithRawMethod_getNumberCurrentUAV() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status getNumberCurrentUAV(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestgetNumberCurrentUAV(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_SetDesiredSpeed : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_SetDesiredSpeed()
        {
            ::grpc::Service::MarkMethodRaw(10);
        }
        ~WithRawMethod_SetDesiredSpeed() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status SetDesiredSpeed(::grpc::ServerContext* /*context*/, const ::airmobisim::UavSetSpeed* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestSetDesiredSpeed(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_UpdateWaypoints : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_UpdateWaypoints()
        {
            ::grpc::Service::MarkMethodRaw(11);
        }
        ~WithRawMethod_UpdateWaypoints() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status UpdateWaypoints(::grpc::ServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestUpdateWaypoints(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_DeleteWaypoint : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_DeleteWaypoint()
        {
            ::grpc::Service::MarkMethodRaw(12);
        }
        ~WithRawMethod_DeleteWaypoint() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status DeleteWaypoint(::grpc::ServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestDeleteWaypoint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_GetMaxSimulationTime : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_GetMaxSimulationTime()
        {
            ::grpc::Service::MarkMethodRaw(13);
        }
        ~WithRawMethod_GetMaxSimulationTime() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetMaxSimulationTime(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestGetMaxSimulationTime(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class WithRawMethod_getMaxSimulationSteps : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithRawMethod_getMaxSimulationSteps()
        {
            ::grpc::Service::MarkMethodRaw(14);
        }
        ~WithRawMethod_getMaxSimulationSteps() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status getMaxSimulationSteps(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::DoubleNumber* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        void RequestgetMaxSimulationSteps(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag)
        {
            ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
        }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_Start : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_Start()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(0,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Start(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_Start() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status Start(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* Start(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* Start(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_ExecuteOneTimeStep : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_ExecuteOneTimeStep()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(1,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExecuteOneTimeStep(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_ExecuteOneTimeStep() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status ExecuteOneTimeStep(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::ResponseQuery* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* ExecuteOneTimeStep(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* ExecuteOneTimeStep(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_Finish : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_Finish()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(2,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Finish(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_Finish() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status Finish(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* Finish(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* Finish(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_GetManagedHosts : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_GetManagedHosts()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(3,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetManagedHosts(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_GetManagedHosts() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetManagedHosts(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::UavList* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* GetManagedHosts(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* GetManagedHosts(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_InsertWaypoints : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_InsertWaypoints()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(4,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->InsertWaypoints(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_InsertWaypoints() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status InsertWaypoints(::grpc::ServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* InsertWaypoints(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* InsertWaypoints(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_InsertWaypoint : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_InsertWaypoint()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(5,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->InsertWaypoint(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_InsertWaypoint() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status InsertWaypoint(::grpc::ServerContext* /*context*/, const ::airmobisim::Waypoint* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* InsertWaypoint(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* InsertWaypoint(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_InsertUAV : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_InsertUAV()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(6,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->InsertUAV(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_InsertUAV() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status InsertUAV(::grpc::ServerContext* /*context*/, const ::airmobisim::StartUav* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* InsertUAV(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* InsertUAV(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_getMaxUavId : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_getMaxUavId()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(7,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getMaxUavId(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_getMaxUavId() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status getMaxUavId(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* getMaxUavId(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* getMaxUavId(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_DeleteUAV : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_DeleteUAV()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(8,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteUAV(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_DeleteUAV() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status DeleteUAV(::grpc::ServerContext* /*context*/, const ::airmobisim::Number* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* DeleteUAV(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* DeleteUAV(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_getNumberCurrentUAV : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_getNumberCurrentUAV()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(9,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getNumberCurrentUAV(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_getNumberCurrentUAV() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status getNumberCurrentUAV(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* getNumberCurrentUAV(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* getNumberCurrentUAV(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_SetDesiredSpeed : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_SetDesiredSpeed()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(10,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetDesiredSpeed(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_SetDesiredSpeed() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status SetDesiredSpeed(::grpc::ServerContext* /*context*/, const ::airmobisim::UavSetSpeed* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* SetDesiredSpeed(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* SetDesiredSpeed(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_UpdateWaypoints : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_UpdateWaypoints()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(11,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateWaypoints(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_UpdateWaypoints() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status UpdateWaypoints(::grpc::ServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* UpdateWaypoints(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* UpdateWaypoints(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_DeleteWaypoint : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_DeleteWaypoint()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(12,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteWaypoint(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_DeleteWaypoint() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status DeleteWaypoint(::grpc::ServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* DeleteWaypoint(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* DeleteWaypoint(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_GetMaxSimulationTime : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_GetMaxSimulationTime()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(13,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetMaxSimulationTime(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_GetMaxSimulationTime() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status GetMaxSimulationTime(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* GetMaxSimulationTime(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* GetMaxSimulationTime(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class ExperimentalWithRawCallbackMethod_getMaxSimulationSteps : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        ExperimentalWithRawCallbackMethod_getMaxSimulationSteps()
        {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
            ::grpc::Service::
    #else
            ::grpc::Service::experimental().
    #endif
            MarkMethodRawCallback(14,
                new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                    [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                        ::grpc::CallbackServerContext*
    #else
                        ::grpc::experimental::CallbackServerContext*
    #endif
                        context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getMaxSimulationSteps(context, request, response); }));
        }
        ~ExperimentalWithRawCallbackMethod_getMaxSimulationSteps() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable synchronous version of this method
        ::grpc::Status getMaxSimulationSteps(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::DoubleNumber* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
        virtual ::grpc::ServerUnaryReactor* getMaxSimulationSteps(
            ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
        virtual ::grpc::experimental::ServerUnaryReactor* getMaxSimulationSteps(
            ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
        { return nullptr; }
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_Start : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_Start()
        {
            ::grpc::Service::MarkMethodStreamed(0,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::google::protobuf::Empty, ::google::protobuf::Empty>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::google::protobuf::Empty, ::google::protobuf::Empty>* streamer) {
                return this->StreamedStart(context,
                       streamer);
            }));
        }
        ~WithStreamedUnaryMethod_Start() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status Start(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedStart(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty, ::google::protobuf::Empty>* server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_ExecuteOneTimeStep : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_ExecuteOneTimeStep()
        {
            ::grpc::Service::MarkMethodStreamed(1,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::google::protobuf::Empty, ::airmobisim::ResponseQuery>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::google::protobuf::Empty, ::airmobisim::ResponseQuery>* streamer) {
                return this->StreamedExecuteOneTimeStep(context,
                       streamer);
            }));
        }
        ~WithStreamedUnaryMethod_ExecuteOneTimeStep() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status ExecuteOneTimeStep(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::ResponseQuery* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedExecuteOneTimeStep(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty, ::airmobisim::ResponseQuery>* server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_Finish : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_Finish()
        {
            ::grpc::Service::MarkMethodStreamed(2,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::google::protobuf::Empty, ::google::protobuf::Empty>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::google::protobuf::Empty, ::google::protobuf::Empty>* streamer) {
                return this->StreamedFinish(context,
                       streamer);
            }));
        }
        ~WithStreamedUnaryMethod_Finish() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status Finish(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedFinish(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty, ::google::protobuf::Empty>* server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_GetManagedHosts : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_GetManagedHosts()
        {
            ::grpc::Service::MarkMethodStreamed(3,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::google::protobuf::Empty, ::airmobisim::UavList>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::google::protobuf::Empty, ::airmobisim::UavList>* streamer) {
                return this->StreamedGetManagedHosts(context,
                       streamer);
            }));
        }
        ~WithStreamedUnaryMethod_GetManagedHosts() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status GetManagedHosts(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::UavList* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedGetManagedHosts(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty, ::airmobisim::UavList>* server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_InsertWaypoints : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_InsertWaypoints()
        {
            ::grpc::Service::MarkMethodStreamed(4,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::airmobisim::WaypointList, ::google::protobuf::Empty>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::airmobisim::WaypointList, ::google::protobuf::Empty>* streamer) {
                return this->StreamedInsertWaypoints(context,
                       streamer);
            }));
        }
        ~WithStreamedUnaryMethod_InsertWaypoints() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status InsertWaypoints(::grpc::ServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedInsertWaypoints(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::airmobisim::WaypointList, ::google::protobuf::Empty>* server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_InsertWaypoint : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_InsertWaypoint()
        {
            ::grpc::Service::MarkMethodStreamed(5,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::airmobisim::Waypoint, ::google::protobuf::Empty>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::airmobisim::Waypoint, ::google::protobuf::Empty>* streamer) {
                return this->StreamedInsertWaypoint(context,
                       streamer);
            }));
        }
        ~WithStreamedUnaryMethod_InsertWaypoint() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status InsertWaypoint(::grpc::ServerContext* /*context*/, const ::airmobisim::Waypoint* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedInsertWaypoint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::airmobisim::Waypoint, ::google::protobuf::Empty>* server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_InsertUAV : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_InsertUAV()
        {
            ::grpc::Service::MarkMethodStreamed(6,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::airmobisim::StartUav, ::google::protobuf::Empty>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::airmobisim::StartUav, ::google::protobuf::Empty>* streamer) {
                return this->StreamedInsertUAV(context,
                       streamer);
            }));
        }
        ~WithStreamedUnaryMethod_InsertUAV() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status InsertUAV(::grpc::ServerContext* /*context*/, const ::airmobisim::StartUav* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedInsertUAV(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::airmobisim::StartUav, ::google::protobuf::Empty>* server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_getMaxUavId : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_getMaxUavId()
        {
            ::grpc::Service::MarkMethodStreamed(7,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::google::protobuf::Empty, ::airmobisim::Number>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::google::protobuf::Empty, ::airmobisim::Number>* streamer) {
                return this->StreamedgetMaxUavId(context,
                       streamer);
            }));
        }
        ~WithStreamedUnaryMethod_getMaxUavId() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status getMaxUavId(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedgetMaxUavId(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty, ::airmobisim::Number>* server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_DeleteUAV : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_DeleteUAV()
        {
            ::grpc::Service::MarkMethodStreamed(8,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::airmobisim::Number, ::google::protobuf::Empty>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::airmobisim::Number, ::google::protobuf::Empty>* streamer) {
                return this->StreamedDeleteUAV(context,
                       streamer);
            }));
        }
        ~WithStreamedUnaryMethod_DeleteUAV() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status DeleteUAV(::grpc::ServerContext* /*context*/, const ::airmobisim::Number* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedDeleteUAV(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::airmobisim::Number, ::google::protobuf::Empty>* server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_getNumberCurrentUAV : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_getNumberCurrentUAV()
        {
            ::grpc::Service::MarkMethodStreamed(9,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::google::protobuf::Empty, ::airmobisim::Number>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::google::protobuf::Empty, ::airmobisim::Number>* streamer) {
                return this->StreamedgetNumberCurrentUAV(context,
                       streamer);
            }));
        }
        ~WithStreamedUnaryMethod_getNumberCurrentUAV() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status getNumberCurrentUAV(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedgetNumberCurrentUAV(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty, ::airmobisim::Number>* server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_SetDesiredSpeed : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_SetDesiredSpeed()
        {
            ::grpc::Service::MarkMethodStreamed(10,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::airmobisim::UavSetSpeed, ::google::protobuf::Empty>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::airmobisim::UavSetSpeed, ::google::protobuf::Empty>* streamer) {
                return this->StreamedSetDesiredSpeed(context,
                       streamer);
            }));
        }
        ~WithStreamedUnaryMethod_SetDesiredSpeed() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status SetDesiredSpeed(::grpc::ServerContext* /*context*/, const ::airmobisim::UavSetSpeed* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedSetDesiredSpeed(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::airmobisim::UavSetSpeed, ::google::protobuf::Empty>* server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_UpdateWaypoints : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_UpdateWaypoints()
        {
            ::grpc::Service::MarkMethodStreamed(11,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::airmobisim::WaypointList, ::google::protobuf::Empty>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::airmobisim::WaypointList, ::google::protobuf::Empty>* streamer) {
                return this->StreamedUpdateWaypoints(context,
                       streamer);
            }));
        }
        ~WithStreamedUnaryMethod_UpdateWaypoints() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status UpdateWaypoints(::grpc::ServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedUpdateWaypoints(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::airmobisim::WaypointList, ::google::protobuf::Empty>* server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_DeleteWaypoint : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_DeleteWaypoint()
        {
            ::grpc::Service::MarkMethodStreamed(12,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::airmobisim::WaypointList, ::google::protobuf::Empty>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::airmobisim::WaypointList, ::google::protobuf::Empty>* streamer) {
                return this->StreamedDeleteWaypoint(context,
                       streamer);
            }));
        }
        ~WithStreamedUnaryMethod_DeleteWaypoint() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status DeleteWaypoint(::grpc::ServerContext* /*context*/, const ::airmobisim::WaypointList* /*request*/, ::google::protobuf::Empty* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedDeleteWaypoint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::airmobisim::WaypointList, ::google::protobuf::Empty>* server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_GetMaxSimulationTime : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_GetMaxSimulationTime()
        {
            ::grpc::Service::MarkMethodStreamed(13,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::google::protobuf::Empty, ::airmobisim::Number>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::google::protobuf::Empty, ::airmobisim::Number>* streamer) {
                return this->StreamedGetMaxSimulationTime(context,
                       streamer);
            }));
        }
        ~WithStreamedUnaryMethod_GetMaxSimulationTime() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status GetMaxSimulationTime(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::Number* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedGetMaxSimulationTime(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty, ::airmobisim::Number>* server_unary_streamer) = 0;
    };
    template <class BaseClass>
    class WithStreamedUnaryMethod_getMaxSimulationSteps : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
    public:
        WithStreamedUnaryMethod_getMaxSimulationSteps()
        {
            ::grpc::Service::MarkMethodStreamed(14,
                new ::grpc::internal::StreamedUnaryHandler<
                    ::google::protobuf::Empty, ::airmobisim::DoubleNumber>(
                    [this](::grpc::ServerContext* context,
                    ::grpc::ServerUnaryStreamer<
                        ::google::protobuf::Empty, ::airmobisim::DoubleNumber>* streamer) {
                return this->StreamedgetMaxSimulationSteps(context,
                       streamer);
            }));
        }
        ~WithStreamedUnaryMethod_getMaxSimulationSteps() override
        {
            BaseClassMustBeDerivedFromService(this);
        }
        // disable regular version of this method
        ::grpc::Status getMaxSimulationSteps(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::airmobisim::DoubleNumber* /*response*/) override
        {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedgetMaxSimulationSteps(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty, ::airmobisim::DoubleNumber>* server_unary_streamer) = 0;
    };
    typedef WithStreamedUnaryMethod_Start<WithStreamedUnaryMethod_ExecuteOneTimeStep<WithStreamedUnaryMethod_Finish<WithStreamedUnaryMethod_GetManagedHosts<WithStreamedUnaryMethod_InsertWaypoints<WithStreamedUnaryMethod_InsertWaypoint<WithStreamedUnaryMethod_InsertUAV<WithStreamedUnaryMethod_getMaxUavId<WithStreamedUnaryMethod_DeleteUAV<WithStreamedUnaryMethod_getNumberCurrentUAV<WithStreamedUnaryMethod_SetDesiredSpeed<WithStreamedUnaryMethod_UpdateWaypoints<WithStreamedUnaryMethod_DeleteWaypoint<WithStreamedUnaryMethod_GetMaxSimulationTime<WithStreamedUnaryMethod_getMaxSimulationSteps<Service>>>>>>>>>>>>>>> StreamedUnaryService;
    typedef Service SplitStreamedService;
    typedef WithStreamedUnaryMethod_Start<WithStreamedUnaryMethod_ExecuteOneTimeStep<WithStreamedUnaryMethod_Finish<WithStreamedUnaryMethod_GetManagedHosts<WithStreamedUnaryMethod_InsertWaypoints<WithStreamedUnaryMethod_InsertWaypoint<WithStreamedUnaryMethod_InsertUAV<WithStreamedUnaryMethod_getMaxUavId<WithStreamedUnaryMethod_DeleteUAV<WithStreamedUnaryMethod_getNumberCurrentUAV<WithStreamedUnaryMethod_SetDesiredSpeed<WithStreamedUnaryMethod_UpdateWaypoints<WithStreamedUnaryMethod_DeleteWaypoint<WithStreamedUnaryMethod_GetMaxSimulationTime<WithStreamedUnaryMethod_getMaxSimulationSteps<Service>>>>>>>>>>>>>>> StreamedService;
};

}  // namespace airmobisim


#endif  // GRPC_airmobisim_2eproto__INCLUDED
